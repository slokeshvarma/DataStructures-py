<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 4: Searching and Sorting</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Unit 4: Searching and Sorting</h1>
    </header>
    <main>
        <section>
            <h2>1. Sequential Search</h2>
            <p>
                Sequential search involves checking each element of a list one by one. 
                It is simple but has O(n) time complexity for an unsorted list.
            </p>
            <pre><code>
def sequential_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

print(sequential_search([4, 2, 1, 5], 5))  # Output: 3
            </code></pre>
        </section>
        <section>
            <h2>2. Binary Search</h2>
            <p>
                Binary search is an efficient algorithm for sorted arrays. It uses a divide-and-conquer 
                approach with O(log n) time complexity.
            </p>
            <pre><code>
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
            </code></pre>
        </section>
        <section>
            <h2>3. Bubble Sort</h2>
            <p>
                Bubble sort repeatedly swaps adjacent elements if they are in the wrong order. 
                It is simple but inefficient for large datasets with O(nÂ²) time complexity.
            </p>
            <pre><code>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [64, 34, 25, 12, 22]
bubble_sort(arr)
print(arr)  # Output: [12, 22, 25, 34, 64]
            </code></pre>
        </section>
        <section>
            <h2>4. Quick Sort</h2>
            <p>
                Quick sort is a divide-and-conquer algorithm that selects a pivot and partitions the array around it. 
                It has an average time complexity of O(n log n).
            </p>
            <pre><code>
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

arr = [10, 7, 8, 9, 1, 5]
print(quick_sort(arr))  # Output: [1, 5, 7, 8, 9, 10]
            </code></pre>
        </section>
    </main>
    <footer>
        <a href="index.html">Back to Index</a>
    </footer>
</body>
</html>