<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 3: Stacks and Queues</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Unit 3: Stacks and Queues</h1>
    </header>
    <main>
        <section>
            <h2>1. Stack Abstract Data Type (ADT)</h2>
            <p>
                A stack is a linear data structure that follows the **Last In, First Out (LIFO)** principle. 
                Common operations include `push`, `pop`, and `peek`. It is used in undo mechanisms, 
                parsing expressions, and recursive function calls.
            </p>
            <pre><code>
class Stack:
    def __init__(self):
        self.stack = []
    
    def push(self, item):
        self.stack.append(item)
    
    def pop(self):
        return self.stack.pop() if self.stack else None
    
    def peek(self):
        return self.stack[-1] if self.stack else None
            </code></pre>
        </section>
        <section>
            <h2>2. Stack Applications</h2>
            <p>
                Stacks are used in many real-world applications like evaluating postfix expressions, 
                syntax parsing, and reversing strings. Here's an example of evaluating postfix expressions.
            </p>
            <pre><code>
def evaluate_postfix(expression):
    stack = []
    for char in expression:
        if char.isdigit():
            stack.append(int(char))
        else:
            b = stack.pop()
            a = stack.pop()
            if char == '+': stack.append(a + b)
            elif char == '-': stack.append(a - b)
            elif char == '*': stack.append(a * b)
            elif char == '/': stack.append(a / b)
    return stack[0]

print(evaluate_postfix("53+82-*"))  # Output: 48
            </code></pre>
        </section>
        <section>
            <h2>3. Queue Abstract Data Type (ADT)</h2>
            <p>
                A queue is a linear data structure that follows the **First In, First Out (FIFO)** principle. 
                Common operations include `enqueue` (add to the rear) and `dequeue` (remove from the front).
            </p>
            <pre><code>
from collections import deque

class Queue:
    def __init__(self):
        self.queue = deque()
    
    def enqueue(self, item):
        self.queue.append(item)
    
    def dequeue(self):
        return self.queue.popleft() if self.queue else None
            </code></pre>
        </section>
        <section>
            <h2>4. Queue Applications</h2>
            <p>
                Queues are used in scheduling, handling requests in web servers, and breadth-first search (BFS). 
                Here's an example of implementing BFS using a queue.
            </p>
            <pre><code>
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            print(vertex, end=" ")
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)

graph = {1: {2, 3}, 2: {4}, 3: {5, 6}, 4: set(), 5: set(), 6: set()}
bfs(graph, 1)  # Output: 1 2 3 4 5 6
            </code></pre>
        </section>
    </main>
    <footer>
        <a href="index.html">Back to Index</a>
    </footer>
</body>
</html>