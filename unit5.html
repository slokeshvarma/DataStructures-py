<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 5: Trees and Graphs</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Unit 5: Trees and Graphs</h1>
    </header>
    <main>
        <section>
            <h2>1. Tree Terminologies</h2>
            <p>
                Trees are hierarchical data structures consisting of nodes. 
                Each node has a value and links to child nodes. Key terminologies include:
                root, leaf, parent, child, height, and depth.
            </p>
        </section>
        <section>
            <h2>2. Binary Trees</h2>
            <p>
                A binary tree is a type of tree where each node can have at most two children, 
                commonly referred to as the left and right child.
            </p>
            <pre><code>
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

# Example of creating a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
            </code></pre>
        </section>
        <section>
            <h2>3. Tree Traversal Algorithms</h2>
            <p>
                Tree traversal involves visiting all nodes of a tree in a specific order. Common methods are:
                Preorder (root, left, right), Inorder (left, root, right), and Postorder (left, right, root).
            </p>
            <pre><code>
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.value, end=" ")
        inorder_traversal(root.right)

inorder_traversal(root)  # Output: 2 1 3
            </code></pre>
        </section>
        <section>
            <h2>4. Binary Search Trees (BST)</h2>
            <p>
                A binary search tree is a binary tree where each node's left child contains values smaller than the node, 
                and the right child contains values greater. This structure allows efficient searching and insertion.
            </p>
        </section>
        <section>
            <h2>5. Graph Traversal</h2>
            <p>
                Graph traversal involves visiting all vertices in a graph. 
                Breadth-First Search (BFS) and Depth-First Search (DFS) are the two main methods.
            </p>
            <pre><code>
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=" ")
    for neighbor in graph[start] - visited:
        dfs(graph, neighbor, visited)

graph = {1: {2, 3}, 2: {4}, 3: {5, 6}, 4: set(), 5: set(), 6: set()}
dfs(graph, 1)  # Output: 1 2 4 3 5 6
            </code></pre>
        </section>
    </main>
    <footer>
        <a href="index.html">Back to Index</a>
    </footer>
</body>
</html>